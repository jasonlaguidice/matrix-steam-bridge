// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.7
// 	protoc        v3.21.12
// source: SteamBridge/Proto/steam_bridge.proto

package steamapi

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Enums
type PersonaState int32

const (
	PersonaState_OFFLINE          PersonaState = 0
	PersonaState_ONLINE           PersonaState = 1
	PersonaState_BUSY             PersonaState = 2
	PersonaState_AWAY             PersonaState = 3
	PersonaState_SNOOZE           PersonaState = 4
	PersonaState_LOOKING_TO_TRADE PersonaState = 5
	PersonaState_LOOKING_TO_PLAY  PersonaState = 6
	PersonaState_INVISIBLE        PersonaState = 7
)

// Enum value maps for PersonaState.
var (
	PersonaState_name = map[int32]string{
		0: "OFFLINE",
		1: "ONLINE",
		2: "BUSY",
		3: "AWAY",
		4: "SNOOZE",
		5: "LOOKING_TO_TRADE",
		6: "LOOKING_TO_PLAY",
		7: "INVISIBLE",
	}
	PersonaState_value = map[string]int32{
		"OFFLINE":          0,
		"ONLINE":           1,
		"BUSY":             2,
		"AWAY":             3,
		"SNOOZE":           4,
		"LOOKING_TO_TRADE": 5,
		"LOOKING_TO_PLAY":  6,
		"INVISIBLE":        7,
	}
)

func (x PersonaState) Enum() *PersonaState {
	p := new(PersonaState)
	*p = x
	return p
}

func (x PersonaState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PersonaState) Descriptor() protoreflect.EnumDescriptor {
	return file_SteamBridge_Proto_steam_bridge_proto_enumTypes[0].Descriptor()
}

func (PersonaState) Type() protoreflect.EnumType {
	return &file_SteamBridge_Proto_steam_bridge_proto_enumTypes[0]
}

func (x PersonaState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PersonaState.Descriptor instead.
func (PersonaState) EnumDescriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{0}
}

type FriendRelationship int32

const (
	FriendRelationship_NONE              FriendRelationship = 0
	FriendRelationship_BLOCKED           FriendRelationship = 1
	FriendRelationship_REQUEST_RECIPIENT FriendRelationship = 2
	FriendRelationship_FRIEND            FriendRelationship = 3
	FriendRelationship_REQUEST_INITIATOR FriendRelationship = 4
	FriendRelationship_IGNORED           FriendRelationship = 5
	FriendRelationship_IGNORED_FRIEND    FriendRelationship = 6
)

// Enum value maps for FriendRelationship.
var (
	FriendRelationship_name = map[int32]string{
		0: "NONE",
		1: "BLOCKED",
		2: "REQUEST_RECIPIENT",
		3: "FRIEND",
		4: "REQUEST_INITIATOR",
		5: "IGNORED",
		6: "IGNORED_FRIEND",
	}
	FriendRelationship_value = map[string]int32{
		"NONE":              0,
		"BLOCKED":           1,
		"REQUEST_RECIPIENT": 2,
		"FRIEND":            3,
		"REQUEST_INITIATOR": 4,
		"IGNORED":           5,
		"IGNORED_FRIEND":    6,
	}
)

func (x FriendRelationship) Enum() *FriendRelationship {
	p := new(FriendRelationship)
	*p = x
	return p
}

func (x FriendRelationship) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FriendRelationship) Descriptor() protoreflect.EnumDescriptor {
	return file_SteamBridge_Proto_steam_bridge_proto_enumTypes[1].Descriptor()
}

func (FriendRelationship) Type() protoreflect.EnumType {
	return &file_SteamBridge_Proto_steam_bridge_proto_enumTypes[1]
}

func (x FriendRelationship) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FriendRelationship.Descriptor instead.
func (FriendRelationship) EnumDescriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{1}
}

type MessageType int32

const (
	MessageType_CHAT_MESSAGE MessageType = 0
	MessageType_TYPING       MessageType = 1
	MessageType_EMOTE        MessageType = 2
	MessageType_INVITE_GAME  MessageType = 3
)

// Enum value maps for MessageType.
var (
	MessageType_name = map[int32]string{
		0: "CHAT_MESSAGE",
		1: "TYPING",
		2: "EMOTE",
		3: "INVITE_GAME",
	}
	MessageType_value = map[string]int32{
		"CHAT_MESSAGE": 0,
		"TYPING":       1,
		"EMOTE":        2,
		"INVITE_GAME":  3,
	}
)

func (x MessageType) Enum() *MessageType {
	p := new(MessageType)
	*p = x
	return p
}

func (x MessageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MessageType) Descriptor() protoreflect.EnumDescriptor {
	return file_SteamBridge_Proto_steam_bridge_proto_enumTypes[2].Descriptor()
}

func (MessageType) Type() protoreflect.EnumType {
	return &file_SteamBridge_Proto_steam_bridge_proto_enumTypes[2]
}

func (x MessageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MessageType.Descriptor instead.
func (MessageType) EnumDescriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{2}
}

type SessionEventType int32

const (
	SessionEventType_LOGGED_OFF       SessionEventType = 0
	SessionEventType_CONNECTION_LOST  SessionEventType = 1
	SessionEventType_SESSION_REPLACED SessionEventType = 2
	SessionEventType_TOKEN_EXPIRED    SessionEventType = 3
	SessionEventType_ACCOUNT_DISABLED SessionEventType = 4
	SessionEventType_KICKED           SessionEventType = 5
)

// Enum value maps for SessionEventType.
var (
	SessionEventType_name = map[int32]string{
		0: "LOGGED_OFF",
		1: "CONNECTION_LOST",
		2: "SESSION_REPLACED",
		3: "TOKEN_EXPIRED",
		4: "ACCOUNT_DISABLED",
		5: "KICKED",
	}
	SessionEventType_value = map[string]int32{
		"LOGGED_OFF":       0,
		"CONNECTION_LOST":  1,
		"SESSION_REPLACED": 2,
		"TOKEN_EXPIRED":    3,
		"ACCOUNT_DISABLED": 4,
		"KICKED":           5,
	}
)

func (x SessionEventType) Enum() *SessionEventType {
	p := new(SessionEventType)
	*p = x
	return p
}

func (x SessionEventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SessionEventType) Descriptor() protoreflect.EnumDescriptor {
	return file_SteamBridge_Proto_steam_bridge_proto_enumTypes[3].Descriptor()
}

func (SessionEventType) Type() protoreflect.EnumType {
	return &file_SteamBridge_Proto_steam_bridge_proto_enumTypes[3]
}

func (x SessionEventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SessionEventType.Descriptor instead.
func (SessionEventType) EnumDescriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{3}
}

type AuthStatusResponse_AuthState int32

const (
	AuthStatusResponse_PENDING       AuthStatusResponse_AuthState = 0
	AuthStatusResponse_AUTHENTICATED AuthStatusResponse_AuthState = 1
	AuthStatusResponse_FAILED        AuthStatusResponse_AuthState = 2
	AuthStatusResponse_EXPIRED       AuthStatusResponse_AuthState = 3
)

// Enum value maps for AuthStatusResponse_AuthState.
var (
	AuthStatusResponse_AuthState_name = map[int32]string{
		0: "PENDING",
		1: "AUTHENTICATED",
		2: "FAILED",
		3: "EXPIRED",
	}
	AuthStatusResponse_AuthState_value = map[string]int32{
		"PENDING":       0,
		"AUTHENTICATED": 1,
		"FAILED":        2,
		"EXPIRED":       3,
	}
)

func (x AuthStatusResponse_AuthState) Enum() *AuthStatusResponse_AuthState {
	p := new(AuthStatusResponse_AuthState)
	*p = x
	return p
}

func (x AuthStatusResponse_AuthState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AuthStatusResponse_AuthState) Descriptor() protoreflect.EnumDescriptor {
	return file_SteamBridge_Proto_steam_bridge_proto_enumTypes[4].Descriptor()
}

func (AuthStatusResponse_AuthState) Type() protoreflect.EnumType {
	return &file_SteamBridge_Proto_steam_bridge_proto_enumTypes[4]
}

func (x AuthStatusResponse_AuthState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AuthStatusResponse_AuthState.Descriptor instead.
func (AuthStatusResponse_AuthState) EnumDescriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{5, 0}
}

// Authentication Messages
type CredentialsLoginRequest struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Username         string                 `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password         string                 `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	GuardCode        string                 `protobuf:"bytes,3,opt,name=guard_code,json=guardCode,proto3" json:"guard_code,omitempty"` // Optional SteamGuard code
	RememberPassword bool                   `protobuf:"varint,4,opt,name=remember_password,json=rememberPassword,proto3" json:"remember_password,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *CredentialsLoginRequest) Reset() {
	*x = CredentialsLoginRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CredentialsLoginRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CredentialsLoginRequest) ProtoMessage() {}

func (x *CredentialsLoginRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CredentialsLoginRequest.ProtoReflect.Descriptor instead.
func (*CredentialsLoginRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{0}
}

func (x *CredentialsLoginRequest) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *CredentialsLoginRequest) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *CredentialsLoginRequest) GetGuardCode() string {
	if x != nil {
		return x.GuardCode
	}
	return ""
}

func (x *CredentialsLoginRequest) GetRememberPassword() bool {
	if x != nil {
		return x.RememberPassword
	}
	return false
}

type QRLoginRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QRLoginRequest) Reset() {
	*x = QRLoginRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QRLoginRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QRLoginRequest) ProtoMessage() {}

func (x *QRLoginRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QRLoginRequest.ProtoReflect.Descriptor instead.
func (*QRLoginRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{1}
}

type QRLoginResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	ChallengeUrl   string                 `protobuf:"bytes,1,opt,name=challenge_url,json=challengeUrl,proto3" json:"challenge_url,omitempty"`         // Raw Steam challenge URL for QR code generation
	QrCodeFallback string                 `protobuf:"bytes,3,opt,name=qr_code_fallback,json=qrCodeFallback,proto3" json:"qr_code_fallback,omitempty"` // Fallback text when URL cannot be used
	SessionId      string                 `protobuf:"bytes,4,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`                  // For polling status
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *QRLoginResponse) Reset() {
	*x = QRLoginResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QRLoginResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QRLoginResponse) ProtoMessage() {}

func (x *QRLoginResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QRLoginResponse.ProtoReflect.Descriptor instead.
func (*QRLoginResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{2}
}

func (x *QRLoginResponse) GetChallengeUrl() string {
	if x != nil {
		return x.ChallengeUrl
	}
	return ""
}

func (x *QRLoginResponse) GetQrCodeFallback() string {
	if x != nil {
		return x.QrCodeFallback
	}
	return ""
}

func (x *QRLoginResponse) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

type LoginResponse struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	Success                   bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	ErrorMessage              string                 `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	AccessToken               string                 `protobuf:"bytes,3,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	RefreshToken              string                 `protobuf:"bytes,4,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
	UserInfo                  *UserInfo              `protobuf:"bytes,5,opt,name=user_info,json=userInfo,proto3" json:"user_info,omitempty"`
	RequiresGuard             bool                   `protobuf:"varint,6,opt,name=requires_guard,json=requiresGuard,proto3" json:"requires_guard,omitempty"`
	RequiresEmailVerification bool                   `protobuf:"varint,7,opt,name=requires_email_verification,json=requiresEmailVerification,proto3" json:"requires_email_verification,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *LoginResponse) Reset() {
	*x = LoginResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LoginResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoginResponse) ProtoMessage() {}

func (x *LoginResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{3}
}

func (x *LoginResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *LoginResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *LoginResponse) GetAccessToken() string {
	if x != nil {
		return x.AccessToken
	}
	return ""
}

func (x *LoginResponse) GetRefreshToken() string {
	if x != nil {
		return x.RefreshToken
	}
	return ""
}

func (x *LoginResponse) GetUserInfo() *UserInfo {
	if x != nil {
		return x.UserInfo
	}
	return nil
}

func (x *LoginResponse) GetRequiresGuard() bool {
	if x != nil {
		return x.RequiresGuard
	}
	return false
}

func (x *LoginResponse) GetRequiresEmailVerification() bool {
	if x != nil {
		return x.RequiresEmailVerification
	}
	return false
}

type AuthStatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"` // For QR login polling
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthStatusRequest) Reset() {
	*x = AuthStatusRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthStatusRequest) ProtoMessage() {}

func (x *AuthStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthStatusRequest.ProtoReflect.Descriptor instead.
func (*AuthStatusRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{4}
}

func (x *AuthStatusRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

type AuthStatusResponse struct {
	state         protoimpl.MessageState       `protogen:"open.v1"`
	State         AuthStatusResponse_AuthState `protobuf:"varint,1,opt,name=state,proto3,enum=steambridge.AuthStatusResponse_AuthState" json:"state,omitempty"`
	ErrorMessage  string                       `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	AccessToken   string                       `protobuf:"bytes,3,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	RefreshToken  string                       `protobuf:"bytes,4,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
	UserInfo      *UserInfo                    `protobuf:"bytes,5,opt,name=user_info,json=userInfo,proto3" json:"user_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthStatusResponse) Reset() {
	*x = AuthStatusResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthStatusResponse) ProtoMessage() {}

func (x *AuthStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthStatusResponse.ProtoReflect.Descriptor instead.
func (*AuthStatusResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{5}
}

func (x *AuthStatusResponse) GetState() AuthStatusResponse_AuthState {
	if x != nil {
		return x.State
	}
	return AuthStatusResponse_PENDING
}

func (x *AuthStatusResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *AuthStatusResponse) GetAccessToken() string {
	if x != nil {
		return x.AccessToken
	}
	return ""
}

func (x *AuthStatusResponse) GetRefreshToken() string {
	if x != nil {
		return x.RefreshToken
	}
	return ""
}

func (x *AuthStatusResponse) GetUserInfo() *UserInfo {
	if x != nil {
		return x.UserInfo
	}
	return nil
}

type LogoutRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogoutRequest) Reset() {
	*x = LogoutRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogoutRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogoutRequest) ProtoMessage() {}

func (x *LogoutRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogoutRequest.ProtoReflect.Descriptor instead.
func (*LogoutRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{6}
}

type TokenReAuthRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	AccessToken   string                 `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	RefreshToken  string                 `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
	Username      string                 `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"` // Required for SteamKit2 compatibility
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TokenReAuthRequest) Reset() {
	*x = TokenReAuthRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenReAuthRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenReAuthRequest) ProtoMessage() {}

func (x *TokenReAuthRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenReAuthRequest.ProtoReflect.Descriptor instead.
func (*TokenReAuthRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{7}
}

func (x *TokenReAuthRequest) GetAccessToken() string {
	if x != nil {
		return x.AccessToken
	}
	return ""
}

func (x *TokenReAuthRequest) GetRefreshToken() string {
	if x != nil {
		return x.RefreshToken
	}
	return ""
}

func (x *TokenReAuthRequest) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

type TokenReAuthResponse struct {
	state           protoimpl.MessageState       `protogen:"open.v1"`
	Success         bool                         `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	ErrorMessage    string                       `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	State           AuthStatusResponse_AuthState `protobuf:"varint,3,opt,name=state,proto3,enum=steambridge.AuthStatusResponse_AuthState" json:"state,omitempty"`
	NewAccessToken  string                       `protobuf:"bytes,4,opt,name=new_access_token,json=newAccessToken,proto3" json:"new_access_token,omitempty"`    // If token was refreshed
	NewRefreshToken string                       `protobuf:"bytes,5,opt,name=new_refresh_token,json=newRefreshToken,proto3" json:"new_refresh_token,omitempty"` // If token was refreshed
	UserInfo        *UserInfo                    `protobuf:"bytes,6,opt,name=user_info,json=userInfo,proto3" json:"user_info,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TokenReAuthResponse) Reset() {
	*x = TokenReAuthResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenReAuthResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenReAuthResponse) ProtoMessage() {}

func (x *TokenReAuthResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenReAuthResponse.ProtoReflect.Descriptor instead.
func (*TokenReAuthResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{8}
}

func (x *TokenReAuthResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *TokenReAuthResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *TokenReAuthResponse) GetState() AuthStatusResponse_AuthState {
	if x != nil {
		return x.State
	}
	return AuthStatusResponse_PENDING
}

func (x *TokenReAuthResponse) GetNewAccessToken() string {
	if x != nil {
		return x.NewAccessToken
	}
	return ""
}

func (x *TokenReAuthResponse) GetNewRefreshToken() string {
	if x != nil {
		return x.NewRefreshToken
	}
	return ""
}

func (x *TokenReAuthResponse) GetUserInfo() *UserInfo {
	if x != nil {
		return x.UserInfo
	}
	return nil
}

type LogoutResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogoutResponse) Reset() {
	*x = LogoutResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogoutResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogoutResponse) ProtoMessage() {}

func (x *LogoutResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogoutResponse.ProtoReflect.Descriptor instead.
func (*LogoutResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{9}
}

func (x *LogoutResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

// User Messages
type UserInfoRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SteamId       uint64                 `protobuf:"varint,1,opt,name=steam_id,json=steamId,proto3" json:"steam_id,omitempty"` // Optional, defaults to current user
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserInfoRequest) Reset() {
	*x = UserInfoRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserInfoRequest) ProtoMessage() {}

func (x *UserInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserInfoRequest.ProtoReflect.Descriptor instead.
func (*UserInfoRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{10}
}

func (x *UserInfoRequest) GetSteamId() uint64 {
	if x != nil {
		return x.SteamId
	}
	return 0
}

type UserInfoResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UserInfo      *UserInfo              `protobuf:"bytes,1,opt,name=user_info,json=userInfo,proto3" json:"user_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserInfoResponse) Reset() {
	*x = UserInfoResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserInfoResponse) ProtoMessage() {}

func (x *UserInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserInfoResponse.ProtoReflect.Descriptor instead.
func (*UserInfoResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{11}
}

func (x *UserInfoResponse) GetUserInfo() *UserInfo {
	if x != nil {
		return x.UserInfo
	}
	return nil
}

type UserInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SteamId       uint64                 `protobuf:"varint,1,opt,name=steam_id,json=steamId,proto3" json:"steam_id,omitempty"`
	AccountName   string                 `protobuf:"bytes,2,opt,name=account_name,json=accountName,proto3" json:"account_name,omitempty"`
	PersonaName   string                 `protobuf:"bytes,3,opt,name=persona_name,json=personaName,proto3" json:"persona_name,omitempty"` // Display name
	ProfileUrl    string                 `protobuf:"bytes,4,opt,name=profile_url,json=profileUrl,proto3" json:"profile_url,omitempty"`
	AvatarUrl     string                 `protobuf:"bytes,5,opt,name=avatar_url,json=avatarUrl,proto3" json:"avatar_url,omitempty"`
	AvatarHash    string                 `protobuf:"bytes,6,opt,name=avatar_hash,json=avatarHash,proto3" json:"avatar_hash,omitempty"` // Base64-encoded SHA-1 hash of avatar for change detection
	Status        PersonaState           `protobuf:"varint,7,opt,name=status,proto3,enum=steambridge.PersonaState" json:"status,omitempty"`
	CurrentGame   string                 `protobuf:"bytes,8,opt,name=current_game,json=currentGame,proto3" json:"current_game,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserInfo) Reset() {
	*x = UserInfo{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserInfo) ProtoMessage() {}

func (x *UserInfo) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserInfo.ProtoReflect.Descriptor instead.
func (*UserInfo) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{12}
}

func (x *UserInfo) GetSteamId() uint64 {
	if x != nil {
		return x.SteamId
	}
	return 0
}

func (x *UserInfo) GetAccountName() string {
	if x != nil {
		return x.AccountName
	}
	return ""
}

func (x *UserInfo) GetPersonaName() string {
	if x != nil {
		return x.PersonaName
	}
	return ""
}

func (x *UserInfo) GetProfileUrl() string {
	if x != nil {
		return x.ProfileUrl
	}
	return ""
}

func (x *UserInfo) GetAvatarUrl() string {
	if x != nil {
		return x.AvatarUrl
	}
	return ""
}

func (x *UserInfo) GetAvatarHash() string {
	if x != nil {
		return x.AvatarHash
	}
	return ""
}

func (x *UserInfo) GetStatus() PersonaState {
	if x != nil {
		return x.Status
	}
	return PersonaState_OFFLINE
}

func (x *UserInfo) GetCurrentGame() string {
	if x != nil {
		return x.CurrentGame
	}
	return ""
}

type FriendsListRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FriendsListRequest) Reset() {
	*x = FriendsListRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FriendsListRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FriendsListRequest) ProtoMessage() {}

func (x *FriendsListRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FriendsListRequest.ProtoReflect.Descriptor instead.
func (*FriendsListRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{13}
}

type FriendsListResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Friends       []*Friend              `protobuf:"bytes,1,rep,name=friends,proto3" json:"friends,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FriendsListResponse) Reset() {
	*x = FriendsListResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FriendsListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FriendsListResponse) ProtoMessage() {}

func (x *FriendsListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FriendsListResponse.ProtoReflect.Descriptor instead.
func (*FriendsListResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{14}
}

func (x *FriendsListResponse) GetFriends() []*Friend {
	if x != nil {
		return x.Friends
	}
	return nil
}

type Friend struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SteamId       uint64                 `protobuf:"varint,1,opt,name=steam_id,json=steamId,proto3" json:"steam_id,omitempty"`
	PersonaName   string                 `protobuf:"bytes,2,opt,name=persona_name,json=personaName,proto3" json:"persona_name,omitempty"`
	AvatarUrl     string                 `protobuf:"bytes,3,opt,name=avatar_url,json=avatarUrl,proto3" json:"avatar_url,omitempty"`
	AvatarHash    string                 `protobuf:"bytes,4,opt,name=avatar_hash,json=avatarHash,proto3" json:"avatar_hash,omitempty"` // Base64-encoded SHA-1 hash of avatar for change detection
	Status        PersonaState           `protobuf:"varint,5,opt,name=status,proto3,enum=steambridge.PersonaState" json:"status,omitempty"`
	CurrentGame   string                 `protobuf:"bytes,6,opt,name=current_game,json=currentGame,proto3" json:"current_game,omitempty"`
	Relationship  FriendRelationship     `protobuf:"varint,7,opt,name=relationship,proto3,enum=steambridge.FriendRelationship" json:"relationship,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Friend) Reset() {
	*x = Friend{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Friend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Friend) ProtoMessage() {}

func (x *Friend) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Friend.ProtoReflect.Descriptor instead.
func (*Friend) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{15}
}

func (x *Friend) GetSteamId() uint64 {
	if x != nil {
		return x.SteamId
	}
	return 0
}

func (x *Friend) GetPersonaName() string {
	if x != nil {
		return x.PersonaName
	}
	return ""
}

func (x *Friend) GetAvatarUrl() string {
	if x != nil {
		return x.AvatarUrl
	}
	return ""
}

func (x *Friend) GetAvatarHash() string {
	if x != nil {
		return x.AvatarHash
	}
	return ""
}

func (x *Friend) GetStatus() PersonaState {
	if x != nil {
		return x.Status
	}
	return PersonaState_OFFLINE
}

func (x *Friend) GetCurrentGame() string {
	if x != nil {
		return x.CurrentGame
	}
	return ""
}

func (x *Friend) GetRelationship() FriendRelationship {
	if x != nil {
		return x.Relationship
	}
	return FriendRelationship_NONE
}

type UserStatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SteamId       uint64                 `protobuf:"varint,1,opt,name=steam_id,json=steamId,proto3" json:"steam_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserStatusRequest) Reset() {
	*x = UserStatusRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserStatusRequest) ProtoMessage() {}

func (x *UserStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserStatusRequest.ProtoReflect.Descriptor instead.
func (*UserStatusRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{16}
}

func (x *UserStatusRequest) GetSteamId() uint64 {
	if x != nil {
		return x.SteamId
	}
	return 0
}

type UserStatusResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Status        PersonaState           `protobuf:"varint,1,opt,name=status,proto3,enum=steambridge.PersonaState" json:"status,omitempty"`
	CurrentGame   string                 `protobuf:"bytes,2,opt,name=current_game,json=currentGame,proto3" json:"current_game,omitempty"`
	LastOnline    int64                  `protobuf:"varint,3,opt,name=last_online,json=lastOnline,proto3" json:"last_online,omitempty"` // Unix timestamp
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserStatusResponse) Reset() {
	*x = UserStatusResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserStatusResponse) ProtoMessage() {}

func (x *UserStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserStatusResponse.ProtoReflect.Descriptor instead.
func (*UserStatusResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{17}
}

func (x *UserStatusResponse) GetStatus() PersonaState {
	if x != nil {
		return x.Status
	}
	return PersonaState_OFFLINE
}

func (x *UserStatusResponse) GetCurrentGame() string {
	if x != nil {
		return x.CurrentGame
	}
	return ""
}

func (x *UserStatusResponse) GetLastOnline() int64 {
	if x != nil {
		return x.LastOnline
	}
	return 0
}

type ResolveVanityURLRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	VanityUrl     string                 `protobuf:"bytes,1,opt,name=vanity_url,json=vanityUrl,proto3" json:"vanity_url,omitempty"` // Username from vanity URL (e.g., "username" from steamcommunity.com/id/username)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResolveVanityURLRequest) Reset() {
	*x = ResolveVanityURLRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResolveVanityURLRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResolveVanityURLRequest) ProtoMessage() {}

func (x *ResolveVanityURLRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResolveVanityURLRequest.ProtoReflect.Descriptor instead.
func (*ResolveVanityURLRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{18}
}

func (x *ResolveVanityURLRequest) GetVanityUrl() string {
	if x != nil {
		return x.VanityUrl
	}
	return ""
}

type ResolveVanityURLResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	SteamId       string                 `protobuf:"bytes,2,opt,name=steam_id,json=steamId,proto3" json:"steam_id,omitempty"` // SteamID64 as string
	ErrorMessage  string                 `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResolveVanityURLResponse) Reset() {
	*x = ResolveVanityURLResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResolveVanityURLResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResolveVanityURLResponse) ProtoMessage() {}

func (x *ResolveVanityURLResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResolveVanityURLResponse.ProtoReflect.Descriptor instead.
func (*ResolveVanityURLResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{19}
}

func (x *ResolveVanityURLResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ResolveVanityURLResponse) GetSteamId() string {
	if x != nil {
		return x.SteamId
	}
	return ""
}

func (x *ResolveVanityURLResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

// Messaging Messages
type SendMessageRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TargetSteamId uint64                 `protobuf:"varint,1,opt,name=target_steam_id,json=targetSteamId,proto3" json:"target_steam_id,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	MessageType   MessageType            `protobuf:"varint,3,opt,name=message_type,json=messageType,proto3,enum=steambridge.MessageType" json:"message_type,omitempty"`
	ImageUrl      *string                `protobuf:"bytes,4,opt,name=image_url,json=imageUrl,proto3,oneof" json:"image_url,omitempty"` // Steam CDN/UFS URL for image messages
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendMessageRequest) Reset() {
	*x = SendMessageRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendMessageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendMessageRequest) ProtoMessage() {}

func (x *SendMessageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendMessageRequest.ProtoReflect.Descriptor instead.
func (*SendMessageRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{20}
}

func (x *SendMessageRequest) GetTargetSteamId() uint64 {
	if x != nil {
		return x.TargetSteamId
	}
	return 0
}

func (x *SendMessageRequest) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *SendMessageRequest) GetMessageType() MessageType {
	if x != nil {
		return x.MessageType
	}
	return MessageType_CHAT_MESSAGE
}

func (x *SendMessageRequest) GetImageUrl() string {
	if x != nil && x.ImageUrl != nil {
		return *x.ImageUrl
	}
	return ""
}

type SendMessageResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	ErrorMessage  string                 `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	Timestamp     int64                  `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendMessageResponse) Reset() {
	*x = SendMessageResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendMessageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendMessageResponse) ProtoMessage() {}

func (x *SendMessageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendMessageResponse.ProtoReflect.Descriptor instead.
func (*SendMessageResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{21}
}

func (x *SendMessageResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SendMessageResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *SendMessageResponse) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

type MessageSubscriptionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MessageSubscriptionRequest) Reset() {
	*x = MessageSubscriptionRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MessageSubscriptionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessageSubscriptionRequest) ProtoMessage() {}

func (x *MessageSubscriptionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MessageSubscriptionRequest.ProtoReflect.Descriptor instead.
func (*MessageSubscriptionRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{22}
}

type MessageEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SenderSteamId uint64                 `protobuf:"varint,1,opt,name=sender_steam_id,json=senderSteamId,proto3" json:"sender_steam_id,omitempty"`
	TargetSteamId uint64                 `protobuf:"varint,2,opt,name=target_steam_id,json=targetSteamId,proto3" json:"target_steam_id,omitempty"`
	Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	MessageType   MessageType            `protobuf:"varint,4,opt,name=message_type,json=messageType,proto3,enum=steambridge.MessageType" json:"message_type,omitempty"`
	Timestamp     int64                  `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	IsEcho        bool                   `protobuf:"varint,6,opt,name=is_echo,json=isEcho,proto3" json:"is_echo,omitempty"`            // True if this is an echo of our own message from another client
	ImageUrl      *string                `protobuf:"bytes,7,opt,name=image_url,json=imageUrl,proto3,oneof" json:"image_url,omitempty"` // Steam CDN/UFS URL for image messages
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MessageEvent) Reset() {
	*x = MessageEvent{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MessageEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessageEvent) ProtoMessage() {}

func (x *MessageEvent) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MessageEvent.ProtoReflect.Descriptor instead.
func (*MessageEvent) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{23}
}

func (x *MessageEvent) GetSenderSteamId() uint64 {
	if x != nil {
		return x.SenderSteamId
	}
	return 0
}

func (x *MessageEvent) GetTargetSteamId() uint64 {
	if x != nil {
		return x.TargetSteamId
	}
	return 0
}

func (x *MessageEvent) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *MessageEvent) GetMessageType() MessageType {
	if x != nil {
		return x.MessageType
	}
	return MessageType_CHAT_MESSAGE
}

func (x *MessageEvent) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *MessageEvent) GetIsEcho() bool {
	if x != nil {
		return x.IsEcho
	}
	return false
}

func (x *MessageEvent) GetImageUrl() string {
	if x != nil && x.ImageUrl != nil {
		return *x.ImageUrl
	}
	return ""
}

type TypingNotificationRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TargetSteamId uint64                 `protobuf:"varint,1,opt,name=target_steam_id,json=targetSteamId,proto3" json:"target_steam_id,omitempty"`
	IsTyping      bool                   `protobuf:"varint,2,opt,name=is_typing,json=isTyping,proto3" json:"is_typing,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TypingNotificationRequest) Reset() {
	*x = TypingNotificationRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TypingNotificationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TypingNotificationRequest) ProtoMessage() {}

func (x *TypingNotificationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TypingNotificationRequest.ProtoReflect.Descriptor instead.
func (*TypingNotificationRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{24}
}

func (x *TypingNotificationRequest) GetTargetSteamId() uint64 {
	if x != nil {
		return x.TargetSteamId
	}
	return 0
}

func (x *TypingNotificationRequest) GetIsTyping() bool {
	if x != nil {
		return x.IsTyping
	}
	return false
}

type TypingNotificationResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TypingNotificationResponse) Reset() {
	*x = TypingNotificationResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TypingNotificationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TypingNotificationResponse) ProtoMessage() {}

func (x *TypingNotificationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TypingNotificationResponse.ProtoReflect.Descriptor instead.
func (*TypingNotificationResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{25}
}

func (x *TypingNotificationResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

// Image Messages
type UploadImageRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ImageData     []byte                 `protobuf:"bytes,1,opt,name=image_data,json=imageData,proto3" json:"image_data,omitempty"`
	MimeType      string                 `protobuf:"bytes,2,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	Filename      string                 `protobuf:"bytes,3,opt,name=filename,proto3" json:"filename,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UploadImageRequest) Reset() {
	*x = UploadImageRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UploadImageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UploadImageRequest) ProtoMessage() {}

func (x *UploadImageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UploadImageRequest.ProtoReflect.Descriptor instead.
func (*UploadImageRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{26}
}

func (x *UploadImageRequest) GetImageData() []byte {
	if x != nil {
		return x.ImageData
	}
	return nil
}

func (x *UploadImageRequest) GetMimeType() string {
	if x != nil {
		return x.MimeType
	}
	return ""
}

func (x *UploadImageRequest) GetFilename() string {
	if x != nil {
		return x.Filename
	}
	return ""
}

type UploadImageResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	ErrorMessage  string                 `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	ImageUrl      string                 `protobuf:"bytes,3,opt,name=image_url,json=imageUrl,proto3" json:"image_url,omitempty"` // Steam UFS/CDN URL
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UploadImageResponse) Reset() {
	*x = UploadImageResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UploadImageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UploadImageResponse) ProtoMessage() {}

func (x *UploadImageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UploadImageResponse.ProtoReflect.Descriptor instead.
func (*UploadImageResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{27}
}

func (x *UploadImageResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *UploadImageResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *UploadImageResponse) GetImageUrl() string {
	if x != nil {
		return x.ImageUrl
	}
	return ""
}

type DownloadImageRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ImageUrl      string                 `protobuf:"bytes,1,opt,name=image_url,json=imageUrl,proto3" json:"image_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DownloadImageRequest) Reset() {
	*x = DownloadImageRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DownloadImageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DownloadImageRequest) ProtoMessage() {}

func (x *DownloadImageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DownloadImageRequest.ProtoReflect.Descriptor instead.
func (*DownloadImageRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{28}
}

func (x *DownloadImageRequest) GetImageUrl() string {
	if x != nil {
		return x.ImageUrl
	}
	return ""
}

type DownloadImageResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	ErrorMessage  string                 `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	ImageData     []byte                 `protobuf:"bytes,3,opt,name=image_data,json=imageData,proto3" json:"image_data,omitempty"`
	MimeType      string                 `protobuf:"bytes,4,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DownloadImageResponse) Reset() {
	*x = DownloadImageResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DownloadImageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DownloadImageResponse) ProtoMessage() {}

func (x *DownloadImageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DownloadImageResponse.ProtoReflect.Descriptor instead.
func (*DownloadImageResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{29}
}

func (x *DownloadImageResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *DownloadImageResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *DownloadImageResponse) GetImageData() []byte {
	if x != nil {
		return x.ImageData
	}
	return nil
}

func (x *DownloadImageResponse) GetMimeType() string {
	if x != nil {
		return x.MimeType
	}
	return ""
}

// Avatar Messages
type GetUserAvatarDataRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SteamId       uint64                 `protobuf:"varint,1,opt,name=steam_id,json=steamId,proto3" json:"steam_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetUserAvatarDataRequest) Reset() {
	*x = GetUserAvatarDataRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetUserAvatarDataRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetUserAvatarDataRequest) ProtoMessage() {}

func (x *GetUserAvatarDataRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetUserAvatarDataRequest.ProtoReflect.Descriptor instead.
func (*GetUserAvatarDataRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{30}
}

func (x *GetUserAvatarDataRequest) GetSteamId() uint64 {
	if x != nil {
		return x.SteamId
	}
	return 0
}

type GetUserAvatarDataResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	ErrorMessage  string                 `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	AvatarHash    string                 `protobuf:"bytes,3,opt,name=avatar_hash,json=avatarHash,proto3" json:"avatar_hash,omitempty"` // Base64-encoded SHA-1 hash for change detection
	AvatarUrl     string                 `protobuf:"bytes,4,opt,name=avatar_url,json=avatarUrl,proto3" json:"avatar_url,omitempty"`    // Avatar URL for fallback
	ImageData     []byte                 `protobuf:"bytes,5,opt,name=image_data,json=imageData,proto3" json:"image_data,omitempty"`    // Avatar image data (empty if download failed)
	MimeType      string                 `protobuf:"bytes,6,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`       // Image MIME type
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetUserAvatarDataResponse) Reset() {
	*x = GetUserAvatarDataResponse{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetUserAvatarDataResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetUserAvatarDataResponse) ProtoMessage() {}

func (x *GetUserAvatarDataResponse) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetUserAvatarDataResponse.ProtoReflect.Descriptor instead.
func (*GetUserAvatarDataResponse) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{31}
}

func (x *GetUserAvatarDataResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *GetUserAvatarDataResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *GetUserAvatarDataResponse) GetAvatarHash() string {
	if x != nil {
		return x.AvatarHash
	}
	return ""
}

func (x *GetUserAvatarDataResponse) GetAvatarUrl() string {
	if x != nil {
		return x.AvatarUrl
	}
	return ""
}

func (x *GetUserAvatarDataResponse) GetImageData() []byte {
	if x != nil {
		return x.ImageData
	}
	return nil
}

func (x *GetUserAvatarDataResponse) GetMimeType() string {
	if x != nil {
		return x.MimeType
	}
	return ""
}

// Session Management Messages
type SessionSubscriptionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SessionSubscriptionRequest) Reset() {
	*x = SessionSubscriptionRequest{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SessionSubscriptionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionSubscriptionRequest) ProtoMessage() {}

func (x *SessionSubscriptionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionSubscriptionRequest.ProtoReflect.Descriptor instead.
func (*SessionSubscriptionRequest) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{32}
}

type SessionEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	EventType     SessionEventType       `protobuf:"varint,1,opt,name=event_type,json=eventType,proto3,enum=steambridge.SessionEventType" json:"event_type,omitempty"`
	Reason        string                 `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"` // Logout reason or error message
	Timestamp     int64                  `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SessionEvent) Reset() {
	*x = SessionEvent{}
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SessionEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionEvent) ProtoMessage() {}

func (x *SessionEvent) ProtoReflect() protoreflect.Message {
	mi := &file_SteamBridge_Proto_steam_bridge_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionEvent.ProtoReflect.Descriptor instead.
func (*SessionEvent) Descriptor() ([]byte, []int) {
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP(), []int{33}
}

func (x *SessionEvent) GetEventType() SessionEventType {
	if x != nil {
		return x.EventType
	}
	return SessionEventType_LOGGED_OFF
}

func (x *SessionEvent) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *SessionEvent) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

var File_SteamBridge_Proto_steam_bridge_proto protoreflect.FileDescriptor

const file_SteamBridge_Proto_steam_bridge_proto_rawDesc = "" +
	"\n" +
	"$SteamBridge/Proto/steam_bridge.proto\x12\vsteambridge\"\x9d\x01\n" +
	"\x17CredentialsLoginRequest\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x12\x1a\n" +
	"\bpassword\x18\x02 \x01(\tR\bpassword\x12\x1d\n" +
	"\n" +
	"guard_code\x18\x03 \x01(\tR\tguardCode\x12+\n" +
	"\x11remember_password\x18\x04 \x01(\bR\x10rememberPassword\"\x10\n" +
	"\x0eQRLoginRequest\"\x7f\n" +
	"\x0fQRLoginResponse\x12#\n" +
	"\rchallenge_url\x18\x01 \x01(\tR\fchallengeUrl\x12(\n" +
	"\x10qr_code_fallback\x18\x03 \x01(\tR\x0eqrCodeFallback\x12\x1d\n" +
	"\n" +
	"session_id\x18\x04 \x01(\tR\tsessionId\"\xb1\x02\n" +
	"\rLoginResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\x12!\n" +
	"\faccess_token\x18\x03 \x01(\tR\vaccessToken\x12#\n" +
	"\rrefresh_token\x18\x04 \x01(\tR\frefreshToken\x122\n" +
	"\tuser_info\x18\x05 \x01(\v2\x15.steambridge.UserInfoR\buserInfo\x12%\n" +
	"\x0erequires_guard\x18\x06 \x01(\bR\rrequiresGuard\x12>\n" +
	"\x1brequires_email_verification\x18\a \x01(\bR\x19requiresEmailVerification\"2\n" +
	"\x11AuthStatusRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\"\xbc\x02\n" +
	"\x12AuthStatusResponse\x12?\n" +
	"\x05state\x18\x01 \x01(\x0e2).steambridge.AuthStatusResponse.AuthStateR\x05state\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\x12!\n" +
	"\faccess_token\x18\x03 \x01(\tR\vaccessToken\x12#\n" +
	"\rrefresh_token\x18\x04 \x01(\tR\frefreshToken\x122\n" +
	"\tuser_info\x18\x05 \x01(\v2\x15.steambridge.UserInfoR\buserInfo\"D\n" +
	"\tAuthState\x12\v\n" +
	"\aPENDING\x10\x00\x12\x11\n" +
	"\rAUTHENTICATED\x10\x01\x12\n" +
	"\n" +
	"\x06FAILED\x10\x02\x12\v\n" +
	"\aEXPIRED\x10\x03\"\x0f\n" +
	"\rLogoutRequest\"x\n" +
	"\x12TokenReAuthRequest\x12!\n" +
	"\faccess_token\x18\x01 \x01(\tR\vaccessToken\x12#\n" +
	"\rrefresh_token\x18\x02 \x01(\tR\frefreshToken\x12\x1a\n" +
	"\busername\x18\x03 \x01(\tR\busername\"\x9f\x02\n" +
	"\x13TokenReAuthResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\x12?\n" +
	"\x05state\x18\x03 \x01(\x0e2).steambridge.AuthStatusResponse.AuthStateR\x05state\x12(\n" +
	"\x10new_access_token\x18\x04 \x01(\tR\x0enewAccessToken\x12*\n" +
	"\x11new_refresh_token\x18\x05 \x01(\tR\x0fnewRefreshToken\x122\n" +
	"\tuser_info\x18\x06 \x01(\v2\x15.steambridge.UserInfoR\buserInfo\"*\n" +
	"\x0eLogoutResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\",\n" +
	"\x0fUserInfoRequest\x12\x19\n" +
	"\bsteam_id\x18\x01 \x01(\x04R\asteamId\"F\n" +
	"\x10UserInfoResponse\x122\n" +
	"\tuser_info\x18\x01 \x01(\v2\x15.steambridge.UserInfoR\buserInfo\"\xa2\x02\n" +
	"\bUserInfo\x12\x19\n" +
	"\bsteam_id\x18\x01 \x01(\x04R\asteamId\x12!\n" +
	"\faccount_name\x18\x02 \x01(\tR\vaccountName\x12!\n" +
	"\fpersona_name\x18\x03 \x01(\tR\vpersonaName\x12\x1f\n" +
	"\vprofile_url\x18\x04 \x01(\tR\n" +
	"profileUrl\x12\x1d\n" +
	"\n" +
	"avatar_url\x18\x05 \x01(\tR\tavatarUrl\x12\x1f\n" +
	"\vavatar_hash\x18\x06 \x01(\tR\n" +
	"avatarHash\x121\n" +
	"\x06status\x18\a \x01(\x0e2\x19.steambridge.PersonaStateR\x06status\x12!\n" +
	"\fcurrent_game\x18\b \x01(\tR\vcurrentGame\"\x14\n" +
	"\x12FriendsListRequest\"D\n" +
	"\x13FriendsListResponse\x12-\n" +
	"\afriends\x18\x01 \x03(\v2\x13.steambridge.FriendR\afriends\"\xa1\x02\n" +
	"\x06Friend\x12\x19\n" +
	"\bsteam_id\x18\x01 \x01(\x04R\asteamId\x12!\n" +
	"\fpersona_name\x18\x02 \x01(\tR\vpersonaName\x12\x1d\n" +
	"\n" +
	"avatar_url\x18\x03 \x01(\tR\tavatarUrl\x12\x1f\n" +
	"\vavatar_hash\x18\x04 \x01(\tR\n" +
	"avatarHash\x121\n" +
	"\x06status\x18\x05 \x01(\x0e2\x19.steambridge.PersonaStateR\x06status\x12!\n" +
	"\fcurrent_game\x18\x06 \x01(\tR\vcurrentGame\x12C\n" +
	"\frelationship\x18\a \x01(\x0e2\x1f.steambridge.FriendRelationshipR\frelationship\".\n" +
	"\x11UserStatusRequest\x12\x19\n" +
	"\bsteam_id\x18\x01 \x01(\x04R\asteamId\"\x8b\x01\n" +
	"\x12UserStatusResponse\x121\n" +
	"\x06status\x18\x01 \x01(\x0e2\x19.steambridge.PersonaStateR\x06status\x12!\n" +
	"\fcurrent_game\x18\x02 \x01(\tR\vcurrentGame\x12\x1f\n" +
	"\vlast_online\x18\x03 \x01(\x03R\n" +
	"lastOnline\"8\n" +
	"\x17ResolveVanityURLRequest\x12\x1d\n" +
	"\n" +
	"vanity_url\x18\x01 \x01(\tR\tvanityUrl\"t\n" +
	"\x18ResolveVanityURLResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x19\n" +
	"\bsteam_id\x18\x02 \x01(\tR\asteamId\x12#\n" +
	"\rerror_message\x18\x03 \x01(\tR\ferrorMessage\"\xc3\x01\n" +
	"\x12SendMessageRequest\x12&\n" +
	"\x0ftarget_steam_id\x18\x01 \x01(\x04R\rtargetSteamId\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12;\n" +
	"\fmessage_type\x18\x03 \x01(\x0e2\x18.steambridge.MessageTypeR\vmessageType\x12 \n" +
	"\timage_url\x18\x04 \x01(\tH\x00R\bimageUrl\x88\x01\x01B\f\n" +
	"\n" +
	"_image_url\"r\n" +
	"\x13SendMessageResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\x12\x1c\n" +
	"\ttimestamp\x18\x03 \x01(\x03R\ttimestamp\"\x1c\n" +
	"\x1aMessageSubscriptionRequest\"\x9c\x02\n" +
	"\fMessageEvent\x12&\n" +
	"\x0fsender_steam_id\x18\x01 \x01(\x04R\rsenderSteamId\x12&\n" +
	"\x0ftarget_steam_id\x18\x02 \x01(\x04R\rtargetSteamId\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\x12;\n" +
	"\fmessage_type\x18\x04 \x01(\x0e2\x18.steambridge.MessageTypeR\vmessageType\x12\x1c\n" +
	"\ttimestamp\x18\x05 \x01(\x03R\ttimestamp\x12\x17\n" +
	"\ais_echo\x18\x06 \x01(\bR\x06isEcho\x12 \n" +
	"\timage_url\x18\a \x01(\tH\x00R\bimageUrl\x88\x01\x01B\f\n" +
	"\n" +
	"_image_url\"`\n" +
	"\x19TypingNotificationRequest\x12&\n" +
	"\x0ftarget_steam_id\x18\x01 \x01(\x04R\rtargetSteamId\x12\x1b\n" +
	"\tis_typing\x18\x02 \x01(\bR\bisTyping\"6\n" +
	"\x1aTypingNotificationResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\"l\n" +
	"\x12UploadImageRequest\x12\x1d\n" +
	"\n" +
	"image_data\x18\x01 \x01(\fR\timageData\x12\x1b\n" +
	"\tmime_type\x18\x02 \x01(\tR\bmimeType\x12\x1a\n" +
	"\bfilename\x18\x03 \x01(\tR\bfilename\"q\n" +
	"\x13UploadImageResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\x12\x1b\n" +
	"\timage_url\x18\x03 \x01(\tR\bimageUrl\"3\n" +
	"\x14DownloadImageRequest\x12\x1b\n" +
	"\timage_url\x18\x01 \x01(\tR\bimageUrl\"\x92\x01\n" +
	"\x15DownloadImageResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\x12\x1d\n" +
	"\n" +
	"image_data\x18\x03 \x01(\fR\timageData\x12\x1b\n" +
	"\tmime_type\x18\x04 \x01(\tR\bmimeType\"5\n" +
	"\x18GetUserAvatarDataRequest\x12\x19\n" +
	"\bsteam_id\x18\x01 \x01(\x04R\asteamId\"\xd6\x01\n" +
	"\x19GetUserAvatarDataResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\x12\x1f\n" +
	"\vavatar_hash\x18\x03 \x01(\tR\n" +
	"avatarHash\x12\x1d\n" +
	"\n" +
	"avatar_url\x18\x04 \x01(\tR\tavatarUrl\x12\x1d\n" +
	"\n" +
	"image_data\x18\x05 \x01(\fR\timageData\x12\x1b\n" +
	"\tmime_type\x18\x06 \x01(\tR\bmimeType\"\x1c\n" +
	"\x1aSessionSubscriptionRequest\"\x82\x01\n" +
	"\fSessionEvent\x12<\n" +
	"\n" +
	"event_type\x18\x01 \x01(\x0e2\x1d.steambridge.SessionEventTypeR\teventType\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\x12\x1c\n" +
	"\ttimestamp\x18\x03 \x01(\x03R\ttimestamp*\x81\x01\n" +
	"\fPersonaState\x12\v\n" +
	"\aOFFLINE\x10\x00\x12\n" +
	"\n" +
	"\x06ONLINE\x10\x01\x12\b\n" +
	"\x04BUSY\x10\x02\x12\b\n" +
	"\x04AWAY\x10\x03\x12\n" +
	"\n" +
	"\x06SNOOZE\x10\x04\x12\x14\n" +
	"\x10LOOKING_TO_TRADE\x10\x05\x12\x13\n" +
	"\x0fLOOKING_TO_PLAY\x10\x06\x12\r\n" +
	"\tINVISIBLE\x10\a*\x86\x01\n" +
	"\x12FriendRelationship\x12\b\n" +
	"\x04NONE\x10\x00\x12\v\n" +
	"\aBLOCKED\x10\x01\x12\x15\n" +
	"\x11REQUEST_RECIPIENT\x10\x02\x12\n" +
	"\n" +
	"\x06FRIEND\x10\x03\x12\x15\n" +
	"\x11REQUEST_INITIATOR\x10\x04\x12\v\n" +
	"\aIGNORED\x10\x05\x12\x12\n" +
	"\x0eIGNORED_FRIEND\x10\x06*G\n" +
	"\vMessageType\x12\x10\n" +
	"\fCHAT_MESSAGE\x10\x00\x12\n" +
	"\n" +
	"\x06TYPING\x10\x01\x12\t\n" +
	"\x05EMOTE\x10\x02\x12\x0f\n" +
	"\vINVITE_GAME\x10\x03*\x82\x01\n" +
	"\x10SessionEventType\x12\x0e\n" +
	"\n" +
	"LOGGED_OFF\x10\x00\x12\x13\n" +
	"\x0fCONNECTION_LOST\x10\x01\x12\x14\n" +
	"\x10SESSION_REPLACED\x10\x02\x12\x11\n" +
	"\rTOKEN_EXPIRED\x10\x03\x12\x14\n" +
	"\x10ACCOUNT_DISABLED\x10\x04\x12\n" +
	"\n" +
	"\x06KICKED\x10\x052\xaa\x03\n" +
	"\x10SteamAuthService\x12X\n" +
	"\x14LoginWithCredentials\x12$.steambridge.CredentialsLoginRequest\x1a\x1a.steambridge.LoginResponse\x12H\n" +
	"\vLoginWithQR\x12\x1b.steambridge.QRLoginRequest\x1a\x1c.steambridge.QRLoginResponse\x12P\n" +
	"\rGetAuthStatus\x12\x1e.steambridge.AuthStatusRequest\x1a\x1f.steambridge.AuthStatusResponse\x12]\n" +
	"\x18ReAuthenticateWithTokens\x12\x1f.steambridge.TokenReAuthRequest\x1a .steambridge.TokenReAuthResponse\x12A\n" +
	"\x06Logout\x12\x1a.steambridge.LogoutRequest\x1a\x1b.steambridge.LogoutResponse2\xe6\x02\n" +
	"\x10SteamUserService\x12J\n" +
	"\vGetUserInfo\x12\x1c.steambridge.UserInfoRequest\x1a\x1d.steambridge.UserInfoResponse\x12S\n" +
	"\x0eGetFriendsList\x12\x1f.steambridge.FriendsListRequest\x1a .steambridge.FriendsListResponse\x12P\n" +
	"\rGetUserStatus\x12\x1e.steambridge.UserStatusRequest\x1a\x1f.steambridge.UserStatusResponse\x12_\n" +
	"\x10ResolveVanityURL\x12$.steambridge.ResolveVanityURLRequest\x1a%.steambridge.ResolveVanityURLResponse2\xcf\x04\n" +
	"\x15SteamMessagingService\x12P\n" +
	"\vSendMessage\x12\x1f.steambridge.SendMessageRequest\x1a .steambridge.SendMessageResponse\x12[\n" +
	"\x13SubscribeToMessages\x12'.steambridge.MessageSubscriptionRequest\x1a\x19.steambridge.MessageEvent0\x01\x12i\n" +
	"\x16SendTypingNotification\x12&.steambridge.TypingNotificationRequest\x1a'.steambridge.TypingNotificationResponse\x12W\n" +
	"\x12UploadImageToSteam\x12\x1f.steambridge.UploadImageRequest\x1a .steambridge.UploadImageResponse\x12_\n" +
	"\x16DownloadImageFromSteam\x12!.steambridge.DownloadImageRequest\x1a\".steambridge.DownloadImageResponse\x12b\n" +
	"\x11GetUserAvatarData\x12%.steambridge.GetUserAvatarDataRequest\x1a&.steambridge.GetUserAvatarDataResponse2w\n" +
	"\x13SteamSessionService\x12`\n" +
	"\x18SubscribeToSessionEvents\x12'.steambridge.SessionSubscriptionRequest\x1a\x19.steambridge.SessionEvent0\x01B;Z%go.shadowdrake.org/steam/pkg/steamapi\xaa\x02\x11SteamBridge.Protob\x06proto3"

var (
	file_SteamBridge_Proto_steam_bridge_proto_rawDescOnce sync.Once
	file_SteamBridge_Proto_steam_bridge_proto_rawDescData []byte
)

func file_SteamBridge_Proto_steam_bridge_proto_rawDescGZIP() []byte {
	file_SteamBridge_Proto_steam_bridge_proto_rawDescOnce.Do(func() {
		file_SteamBridge_Proto_steam_bridge_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_SteamBridge_Proto_steam_bridge_proto_rawDesc), len(file_SteamBridge_Proto_steam_bridge_proto_rawDesc)))
	})
	return file_SteamBridge_Proto_steam_bridge_proto_rawDescData
}

var file_SteamBridge_Proto_steam_bridge_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_SteamBridge_Proto_steam_bridge_proto_msgTypes = make([]protoimpl.MessageInfo, 34)
var file_SteamBridge_Proto_steam_bridge_proto_goTypes = []any{
	(PersonaState)(0),                  // 0: steambridge.PersonaState
	(FriendRelationship)(0),            // 1: steambridge.FriendRelationship
	(MessageType)(0),                   // 2: steambridge.MessageType
	(SessionEventType)(0),              // 3: steambridge.SessionEventType
	(AuthStatusResponse_AuthState)(0),  // 4: steambridge.AuthStatusResponse.AuthState
	(*CredentialsLoginRequest)(nil),    // 5: steambridge.CredentialsLoginRequest
	(*QRLoginRequest)(nil),             // 6: steambridge.QRLoginRequest
	(*QRLoginResponse)(nil),            // 7: steambridge.QRLoginResponse
	(*LoginResponse)(nil),              // 8: steambridge.LoginResponse
	(*AuthStatusRequest)(nil),          // 9: steambridge.AuthStatusRequest
	(*AuthStatusResponse)(nil),         // 10: steambridge.AuthStatusResponse
	(*LogoutRequest)(nil),              // 11: steambridge.LogoutRequest
	(*TokenReAuthRequest)(nil),         // 12: steambridge.TokenReAuthRequest
	(*TokenReAuthResponse)(nil),        // 13: steambridge.TokenReAuthResponse
	(*LogoutResponse)(nil),             // 14: steambridge.LogoutResponse
	(*UserInfoRequest)(nil),            // 15: steambridge.UserInfoRequest
	(*UserInfoResponse)(nil),           // 16: steambridge.UserInfoResponse
	(*UserInfo)(nil),                   // 17: steambridge.UserInfo
	(*FriendsListRequest)(nil),         // 18: steambridge.FriendsListRequest
	(*FriendsListResponse)(nil),        // 19: steambridge.FriendsListResponse
	(*Friend)(nil),                     // 20: steambridge.Friend
	(*UserStatusRequest)(nil),          // 21: steambridge.UserStatusRequest
	(*UserStatusResponse)(nil),         // 22: steambridge.UserStatusResponse
	(*ResolveVanityURLRequest)(nil),    // 23: steambridge.ResolveVanityURLRequest
	(*ResolveVanityURLResponse)(nil),   // 24: steambridge.ResolveVanityURLResponse
	(*SendMessageRequest)(nil),         // 25: steambridge.SendMessageRequest
	(*SendMessageResponse)(nil),        // 26: steambridge.SendMessageResponse
	(*MessageSubscriptionRequest)(nil), // 27: steambridge.MessageSubscriptionRequest
	(*MessageEvent)(nil),               // 28: steambridge.MessageEvent
	(*TypingNotificationRequest)(nil),  // 29: steambridge.TypingNotificationRequest
	(*TypingNotificationResponse)(nil), // 30: steambridge.TypingNotificationResponse
	(*UploadImageRequest)(nil),         // 31: steambridge.UploadImageRequest
	(*UploadImageResponse)(nil),        // 32: steambridge.UploadImageResponse
	(*DownloadImageRequest)(nil),       // 33: steambridge.DownloadImageRequest
	(*DownloadImageResponse)(nil),      // 34: steambridge.DownloadImageResponse
	(*GetUserAvatarDataRequest)(nil),   // 35: steambridge.GetUserAvatarDataRequest
	(*GetUserAvatarDataResponse)(nil),  // 36: steambridge.GetUserAvatarDataResponse
	(*SessionSubscriptionRequest)(nil), // 37: steambridge.SessionSubscriptionRequest
	(*SessionEvent)(nil),               // 38: steambridge.SessionEvent
}
var file_SteamBridge_Proto_steam_bridge_proto_depIdxs = []int32{
	17, // 0: steambridge.LoginResponse.user_info:type_name -> steambridge.UserInfo
	4,  // 1: steambridge.AuthStatusResponse.state:type_name -> steambridge.AuthStatusResponse.AuthState
	17, // 2: steambridge.AuthStatusResponse.user_info:type_name -> steambridge.UserInfo
	4,  // 3: steambridge.TokenReAuthResponse.state:type_name -> steambridge.AuthStatusResponse.AuthState
	17, // 4: steambridge.TokenReAuthResponse.user_info:type_name -> steambridge.UserInfo
	17, // 5: steambridge.UserInfoResponse.user_info:type_name -> steambridge.UserInfo
	0,  // 6: steambridge.UserInfo.status:type_name -> steambridge.PersonaState
	20, // 7: steambridge.FriendsListResponse.friends:type_name -> steambridge.Friend
	0,  // 8: steambridge.Friend.status:type_name -> steambridge.PersonaState
	1,  // 9: steambridge.Friend.relationship:type_name -> steambridge.FriendRelationship
	0,  // 10: steambridge.UserStatusResponse.status:type_name -> steambridge.PersonaState
	2,  // 11: steambridge.SendMessageRequest.message_type:type_name -> steambridge.MessageType
	2,  // 12: steambridge.MessageEvent.message_type:type_name -> steambridge.MessageType
	3,  // 13: steambridge.SessionEvent.event_type:type_name -> steambridge.SessionEventType
	5,  // 14: steambridge.SteamAuthService.LoginWithCredentials:input_type -> steambridge.CredentialsLoginRequest
	6,  // 15: steambridge.SteamAuthService.LoginWithQR:input_type -> steambridge.QRLoginRequest
	9,  // 16: steambridge.SteamAuthService.GetAuthStatus:input_type -> steambridge.AuthStatusRequest
	12, // 17: steambridge.SteamAuthService.ReAuthenticateWithTokens:input_type -> steambridge.TokenReAuthRequest
	11, // 18: steambridge.SteamAuthService.Logout:input_type -> steambridge.LogoutRequest
	15, // 19: steambridge.SteamUserService.GetUserInfo:input_type -> steambridge.UserInfoRequest
	18, // 20: steambridge.SteamUserService.GetFriendsList:input_type -> steambridge.FriendsListRequest
	21, // 21: steambridge.SteamUserService.GetUserStatus:input_type -> steambridge.UserStatusRequest
	23, // 22: steambridge.SteamUserService.ResolveVanityURL:input_type -> steambridge.ResolveVanityURLRequest
	25, // 23: steambridge.SteamMessagingService.SendMessage:input_type -> steambridge.SendMessageRequest
	27, // 24: steambridge.SteamMessagingService.SubscribeToMessages:input_type -> steambridge.MessageSubscriptionRequest
	29, // 25: steambridge.SteamMessagingService.SendTypingNotification:input_type -> steambridge.TypingNotificationRequest
	31, // 26: steambridge.SteamMessagingService.UploadImageToSteam:input_type -> steambridge.UploadImageRequest
	33, // 27: steambridge.SteamMessagingService.DownloadImageFromSteam:input_type -> steambridge.DownloadImageRequest
	35, // 28: steambridge.SteamMessagingService.GetUserAvatarData:input_type -> steambridge.GetUserAvatarDataRequest
	37, // 29: steambridge.SteamSessionService.SubscribeToSessionEvents:input_type -> steambridge.SessionSubscriptionRequest
	8,  // 30: steambridge.SteamAuthService.LoginWithCredentials:output_type -> steambridge.LoginResponse
	7,  // 31: steambridge.SteamAuthService.LoginWithQR:output_type -> steambridge.QRLoginResponse
	10, // 32: steambridge.SteamAuthService.GetAuthStatus:output_type -> steambridge.AuthStatusResponse
	13, // 33: steambridge.SteamAuthService.ReAuthenticateWithTokens:output_type -> steambridge.TokenReAuthResponse
	14, // 34: steambridge.SteamAuthService.Logout:output_type -> steambridge.LogoutResponse
	16, // 35: steambridge.SteamUserService.GetUserInfo:output_type -> steambridge.UserInfoResponse
	19, // 36: steambridge.SteamUserService.GetFriendsList:output_type -> steambridge.FriendsListResponse
	22, // 37: steambridge.SteamUserService.GetUserStatus:output_type -> steambridge.UserStatusResponse
	24, // 38: steambridge.SteamUserService.ResolveVanityURL:output_type -> steambridge.ResolveVanityURLResponse
	26, // 39: steambridge.SteamMessagingService.SendMessage:output_type -> steambridge.SendMessageResponse
	28, // 40: steambridge.SteamMessagingService.SubscribeToMessages:output_type -> steambridge.MessageEvent
	30, // 41: steambridge.SteamMessagingService.SendTypingNotification:output_type -> steambridge.TypingNotificationResponse
	32, // 42: steambridge.SteamMessagingService.UploadImageToSteam:output_type -> steambridge.UploadImageResponse
	34, // 43: steambridge.SteamMessagingService.DownloadImageFromSteam:output_type -> steambridge.DownloadImageResponse
	36, // 44: steambridge.SteamMessagingService.GetUserAvatarData:output_type -> steambridge.GetUserAvatarDataResponse
	38, // 45: steambridge.SteamSessionService.SubscribeToSessionEvents:output_type -> steambridge.SessionEvent
	30, // [30:46] is the sub-list for method output_type
	14, // [14:30] is the sub-list for method input_type
	14, // [14:14] is the sub-list for extension type_name
	14, // [14:14] is the sub-list for extension extendee
	0,  // [0:14] is the sub-list for field type_name
}

func init() { file_SteamBridge_Proto_steam_bridge_proto_init() }
func file_SteamBridge_Proto_steam_bridge_proto_init() {
	if File_SteamBridge_Proto_steam_bridge_proto != nil {
		return
	}
	file_SteamBridge_Proto_steam_bridge_proto_msgTypes[20].OneofWrappers = []any{}
	file_SteamBridge_Proto_steam_bridge_proto_msgTypes[23].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_SteamBridge_Proto_steam_bridge_proto_rawDesc), len(file_SteamBridge_Proto_steam_bridge_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   34,
			NumExtensions: 0,
			NumServices:   4,
		},
		GoTypes:           file_SteamBridge_Proto_steam_bridge_proto_goTypes,
		DependencyIndexes: file_SteamBridge_Proto_steam_bridge_proto_depIdxs,
		EnumInfos:         file_SteamBridge_Proto_steam_bridge_proto_enumTypes,
		MessageInfos:      file_SteamBridge_Proto_steam_bridge_proto_msgTypes,
	}.Build()
	File_SteamBridge_Proto_steam_bridge_proto = out.File
	file_SteamBridge_Proto_steam_bridge_proto_goTypes = nil
	file_SteamBridge_Proto_steam_bridge_proto_depIdxs = nil
}
